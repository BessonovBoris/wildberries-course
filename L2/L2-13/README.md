# Чтение и понимание кода. Объяснить вывод программы

[Код](./src/main.rs)

## Комментарии к коду

Объявление кортежной структуры без имени поля
```rust
struct Example(i32);
```
\
Реализация трейта `Drop` для структуры `Example`\
Метод `drop()` вызывается автоматически, когда переменная выходит из области видимости (например, когда она больше не используется)\
При вызове метода выводится значение поля (`self.0`)
```rust
impl Drop for Example {
    fn drop(&mut self) {
        println!("{}", self.0);
    }
}
```
\
Объявление кортежной структуры, которая содержит в себе экземпляр структуры `Example`
```rust
struct ExampleWrap(Example);
```
\
Реализация трейта `Drop`
```rust
impl Drop for ExampleWrap {
    fn drop(&mut self) {
        ...
    }
}
```
\
Метод `std::mem::replace()` перемещает значение `Example(0)` в `self.0`, затем возвращает старое значение `self.0`
Затем выводится строка со значением старого поля `self.0.0`
```rust
let e = std::mem::replace(&mut self.0, Example(0));
println!("wrap {}", e.0);
```

После завершения функции `e` выходит из области видимости и вызывается `e.drop()`
```rust
impl Drop for ExampleWrap {
    fn drop(&mut self) {
        let e = std::mem::replace(&mut self.0, Example(0));
        println!("wrap {}", e.0);
    } -> e.drop()
}
```

## d

Создается объект `Example` со значением поля `1`
Так как значение не сохраняется в переменной, для нее сразу будет вызван `drop()`, и выведется `1`
```rust
Example(1);
```
\
Создаются объекты `Example(2)`, `Example(3)` и сохраняется в переменные\
Объекты удалится, когда переменные выйдут из области видимости (при завершении функции main)\
Сначала выведется `3`, так как переменные лежат на стеке

    стек при завершении:
        ...
        _e3
        _e2

    Порядок вызова drop():
        _e3.drop() -> вывод 3
        _e2.drop() -> вывод 2
```rust
let _e2 = Example(2);
let _e3 = Example(3);
```
\
Создаётся объект `Example(4)`, но не сохраняется. Как и с `Example(1)`, он будет удалён по завершении этой строки.
Вызовется метод `drop()`, выведется `4`
```rust
let _ = Example(4);
```
\
Сначала в переменную `_e5` помещается объект `Some(Example(5))` типа `Option`\
Затем переменной `_e5` присваивается `None`, что приводит к вызову `drop()` у `Example(5)`\
В консоль выведется `5`
```rust
let mut _e5;

_e5 = Some(Example(5));
_e5 = None;
```
\
Создаётся объект `Example(6)` и сохраняется в переменную `e6`\
Вызов `drop(e6)` вручную уничтожает объект `Example(6)`\
В консоль выведется `6`
```rust
let e6 = Example(6);
drop(e6);
```
\
Такое же создание объекта\
Метод `std::mem::forget` перехватывает владение переменной и \'забывает\' о ней, при этом не происходит вызова `drop()`\
В консоль ничего не выведется
```rust
let e7 = Example(7);
std::mem::forget(e7);
```
\
Создаётся объект `Example(8)` и оборачивается в структуру ExampleWrap\
В переменной не сохраняется, поэтому сразу вызывается `drop`, который заменяет поле `self.0` (внутренний Example) на `Example(0)`\
В консоль выведется `wrap 8`

После этого вызывается `drop` для `Example(8)`\
В консоль выведется `8`
```rust
ExampleWrap(Example(8));
```

## Порядок вызовов drop()
1. `Example(1);`
2. `let _ = Example(4);`
3. `drop(_e5)` После `_e5 = None;`
4. `drop(e6);`
5. `drop(Example(8))` в функции `drop` у `ExampleWrap`
6. `drop(ExampleWrap(...))`
7. `drop(_e3)`
8. `drop(_e2)`