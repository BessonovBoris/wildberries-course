# Чтение и понимание кода. Объяснить вывод программы

[Код](./src/main.rs)

## Комментарии

`std::sync::mpsc::channel::<T>` возвращает кортеж `(Sender, Reciever)`\
`mpsc` - означает `multi-producer, single-consumer` (можно создать несколько производителей, но будет только один потребитель)\
`Sender` - отправляет `i32`\
`Reciever` - принимает `i32`
```rust
let (tx, rv) = std::sync::mpsc::channel::<i32>();
```
\
`std::thread::spawn` - создаёт новый поток и запускает в нем замыкание FnOnce

    FnOnce применяется к замыканиям, которые могут быть вызваны один раз
```rust
let handle = std::thread::spawn(...);
```
\
Замыкание\
`move` означает, что идет захват использованных переменных (`tx`)\
`||` - нет входных параметров\
Нет `->` - отсутствие возвращаемых значений(вернется `()` пустой кортеж)
```rust
move || { 
    ...
}
```
\
Передача чисел из дочернего канала в основной\
`tx: Sender` - нужен для передачи данных\
`send()` - передает данные, возвращает `Err`, если получатель был освобожден, `Ok`, если данные дошли (необязательно получены)\
`unwrap()` - паникует, если `send()` вернул `Err`
```rust
for i in 0..10 {
    tx.send(i).unwrap();
}
```
\
`handle` - это дескриптор созданного потока, который был возвращён вызовом `std::thread::spawn`\
`join()` - ожидает завершения потока, программа будет простаивать, пока дочерний поток завершит свою работу\
`unwrap()` - если возникла ошибка, произойдёт паника, иначе нет
```rust
handle.join().unwrap();
```
\
`rv` - потребитель нужен, чтобы получить все данные\
`rv.iter()` создаёт итератор по значениям. Перебираем все значения, которые были отправлены потоком через передатчик `tx`\
Для каждого значения `i` выводится строка с его значением с помощью макроса `println!`. Форматирование `{i:?}` используется для вывода значения в отладочном формате
```rust
for i in rv.iter() {
    println!("{i:?}");
}
```

## Объяснение вывода
Так как в новый поток передается весь цикл, то порядок этих чисел не изменится

Вывод
`
0
1
2
3
4
5
6
7
8
9
`