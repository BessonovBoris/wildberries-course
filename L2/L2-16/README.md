# Чтение и понимание кода. Объяснить вывод программы

[Код](./src/main.rs)

## Комментарии


### as_chan()
*Краткое описание*: создает канал, отправляет по нему срез чисел, возвращает Receiver этого канала

`vs: &[i32]` — принимает срез массива чисел (`i32`)\
`std::sync::mpsc::Receiver<i32>` - возвращает часть канала, которая получает сообщения
```rust
fn as_chan(vs: &[i32]) -> std::sync::mpsc::Receiver<i32> {
```
\
Создается канал для передачи данных между потоками\
`tx` — передатчик\
`rx` — приёмник
```rust
let (tx, rx) = std::sync::mpsc::channel();
```
\
Создается новый поток, в нем запускается замыкание
```rust
let handle = std::thread::spawn(...)
```
\
Создает копию вектора, чтобы передать её в поток, так как у замыкания стоит `move` это означает, что переменные захватываются 
```rust
let vs = vs.to_owned();
```
\
Замыкание\
С помощью `move` захватывает переменные\
`tx.send(v).unwrap();` отправляет данные через канал, паникует если вернул `Err`\
`std::thread::sleep` - переводит поток в спящий режим на 1 секунду
```rust
move || {
    for v in vs {
        tx.send(v).unwrap();
        std::thread::sleep(std::time::Duration::from_secs(1))
    }

    drop(tx);
}
```
\
Основной поток ждет завершения дочернего\
Функция возвращает `rx: Receiver` - приемник
```rust
handle.join().unwrap();
rx
```

### merge()
*Краткое описание*: Получает два канала *потребителя*, последовательно читает сообщение из первого канала, затем из второго и тд.
пока оба каналы получают сообщения, возвращает Потребителя нового канала, в который записывались сообщения

Функция принимает Потребителей по значению, происходит перемещение значений
```rust
fn merge(
    a: std::sync::mpsc::Receiver<i32>,
    b: std::sync::mpsc::Receiver<i32>,
) -> std::sync::mpsc::Receiver<i32> { ... }
```
\
`try_recv()` в отличие от `recv()` не ожидает получения сообщения, а только проверяет, есть сообщение(`Ok`)
или нет `Err`\
Если сообщение пришло, то оно отправляется в следующий канал, иначе цикл прерывается
```rust
loop {
    match a.try_recv() {
        Ok(i) => {
            tx.send(i).unwrap();
        }
        Err(_) => {
            a_done = true;
        }
    }
    ...
}
```
\
`match` идентичен предыдущему\
Условие прерывает цикл, если хотя бы один Потребитель не получил сообщение\
В конце функция возвращает Потребителя нового канала
```rust
loop {
        ...
        match b.try_recv() {
            Ok(i) => {
                tx.send(i).unwrap();
            }

            Err(_) => {
                b_done = true;
            }
        }

        if a_done && b_done {
            break;
        }
    }

rx
```

### main()

Создаются два канала `a`, `b`. В которые записываются числа. В функции происходит ожидание, чтобы все числа успели передаться
```rust
let a = as_chan(&vec![1, 3, 5, 7]);
let b = as_chan(&vec![2, 4, 6, 8]);
```
\
Сообщения из двух каналов `a` и `b` сливаются в общий канал `c`, где сообщения идут друг за другом (из канала 1-ого, 2-ого, 1-ого и тд.)
```rust
let c = merge(a, b);
```
\
`c.iter()` возвращает итератор на Потребителя, происходит чтение и вывод чисел\
Так как данные передавались последовательно, а в `merge()` они перегруппировались, то вывод будет всегда однозначным
```rust
for v in c.iter() {
    println!("{v:?}");
}
```

### Вывод

`
1
2
3
4
5
6
7
8`